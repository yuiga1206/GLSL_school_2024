


==========================================================================
==========================================================================
==========================================================================
 // ★★ 
 // ★★ 

@@@


全5回


 // ★★ 
 // ★★ 

@@@


=====================================
24/11/23 第2回
=====================================
---【前半：座学】---

行列を使うことで 頂点の座標変換が簡単かつ効率的に 行えるから。

立体的に見えるようなビジュアルを実現するためには様々な変換が必要であり、
それを簡潔に行うための概念として行列を用いる場合が多い。


頂点シェーダは、頂点の座標などをattribute 変数として受け取り、
それを行列などを用いて変換するのが役目である。

ときには数万あるいは数十万という膨大な量の頂点が、
漏れなく頂点シェーダによって変換されるわけですから、
やっぱりこれは JavaScript などで地道に計算するのは現実的ではなく、
高速な GPU を利用したシェーダだからこそ実現できることだと言えるでしょう。


行列・線形代数…？





---【後半：実習】---

---【006】---

mvp = モデル・ビュー・プロジェクション

const eye         = v3.create(0.0, 0.0, 3.0);
↑これを変更すると、オブジェクトが近づいているように見えてダイナミックに見えた。


行列には、複数の効果を合成してまとめることができるという特性があります。
これは 3D が云々とか WebGL がどうしたという話ではなく、単純に 行列の持つ数学的な特性 です。

行列の効果により立体的に見えるような描画結果が得られる。

深度テストの話：1:30~~


「カラーバッファの情報から深度テストをする？と思うのですが、実行されるタイミングは頂点シェーダーとフラグメントシェーダーの間でしょうか？」
→　カラーバッファと深度バッファは別のもので、深度バッファの結果を使うのは、フラグメントシェーダより後のはず………たぶん。


行列を乗算
http://matrixmultiplication.xyz/

ベクトル　=　1列しかない行列と同じ意味。
なので、行列とベクトルの乗算が出来る。

identity()
乗算しても何も変わらない行列　=　単位行列



=====================================

sin は縦方向の移動に対応していて、
cos はヨコ方向に対応している。
https://www.mathwarehouse.com/animated-gifs/#sine-cosine-unit-circle
↑
めっちゃわかりやすい sin / cos の図……！！

=====================================


行列処理は JS 内で行う！
シェーダ内で行うと、頂点計算時に毎回行列計算が走ってしまう。








---【007】---

線形補間　=　一定の変化
イージングとかは線形補間ではない。


【使いどころ】
意味の無い形から、文字の形にするとか……






---【008】---

クォータニオン


2:55 ~ くらいからもう一回見てみること！！！

わかりにくかったら図にする







---【009】---

SVGやGIFは読み込み怪しい…。出来なくはないが、直接は無理かも。


createTextureFromFile の説明
3:35 ~


自分がわかるところから、少しづつ変えていく。








---【010】---






---【011】---


係数マップ

https://tympanus.net/Development/DistortionHoverEffect/



「テクスチャについて質問です。元画像のアスペクト比と、テクスチャを貼り付けたい板ポリのアスペクト比が異なる場合は、テクスチャ座標をうまくフィットするように計算するという認識で良いでしょうか？」
→　長辺に合わせたいのか、短辺に合わせたいのか。
だいたいはcover的な計算をしますね。短辺合わせ（containだと長辺合わせ）。
「GLSL background cover」とかで検索してみる。


「ちょっと話が戻るのですが、四角形ポリゴンを描画する際に「gl.TRIANGLESだと頂点が6つ必要」というお話があったと思います。IBOを使うことでgl.TRIANGLESでも頂点4つで定義可能かと思いますが、今回gl.TRIANGLE_STRIPで描画している理由は、IBOを管理するコストを避けるためという理解で正しいでしょうか？ IBO + gl.TRIANGLESの場合と、gl.TRIANGLE_STRIP の場合でパフォーマンスに違いはありますでしょうか？」
→　IBO説明する時間がなかったので、gl.TRIANGLE_STRIPを使いました。
パフォーマンスの違いは、基本的には「IBO + gl.TRIANGLES」の方が良いと言われているが、都市伝説的で、誰も検証してない…。
ただ、IBOを使うとメモリも使うので、現代では差はほとんど無いかも。。






---【まとめ】---






課題：

今回の課題は、テクスチャを使った表現に挑戦してみましょう。
テクスチャとポリゴンを組み合わせて、
フラグメントシェーダで表現を工夫するのもよいでしょうし、
テクスチャと点、あるいは線と組み合わせてもなにか面白いことができるかもしれません。



マウスカーソルに合わせて、テクスチャが変化する…とか。



------------------
【講義後の質問】
------------------


